{
  "language": "Solidity",
  "sources": {
    "src/interfaces/ILoot.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface ILoot is IERC721Metadata, IERC721Enumerable {\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/YooLoot.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.7;\n\nimport \"./interfaces/ILoot.sol\";\nimport \"./interfaces/ILootXP.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract YooLoot {\n    event LootDeckSubmitted(address indexed player, uint256 indexed lootId, bytes32 deckHash);\n    event LootDeckCanceled(address indexed player, uint256 indexed lootId);\n\n    event LootDeckRevealed(uint256 indexed lootId, uint8[8] deck);\n\n    event WinnerWithdrawal(address indexed winner, address indexed playerPastOwner, uint256 indexed lootId);\n    event LootWithdrawn(address indexed player, uint256 indexed lootId, uint256 xpGaimed);\n\n\n    event Cloned(address indexed loot, bool winnerGetLoot, uint8 commit3HPeriod, uint8 reveal3HPeriod, uint8 winner3HPeriod, address newYooLoot, bool authorizedAsXPSource);\n\n    struct Parameters {\n        ILoot loot;\n        uint40 startTime;\n        uint8 commit3HPeriod;\n        uint8 reveal3HPeriod;\n        uint8 winner3HPeriod;\n        bool winnerGetLoot;\n    }\n\n    struct TokenData {\n        uint256 id;\n        string tokenURI;\n        uint8[8] deckPower;\n    }\n\n    mapping(uint256 => address) public deposits;\n    Parameters public parameters;\n    mapping(uint256 => bytes32) public deckHashes;\n    mapping(uint8 => mapping(uint8 => uint256)) public rounds;\n\n\n    address private immutable _originalLoot;\n    address private immutable _mloot;\n    address private immutable _lootForEveryone;\n\n    ILootXP private immutable _lootXP;\n\n    constructor(\n        ILootXP lootXP,\n        address[3] memory authorizedLoots,\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) {\n        _lootXP = lootXP;\n        _originalLoot = authorizedLoots[0];\n        _mloot = authorizedLoots[1];\n        _lootForEveryone = authorizedLoots[2];\n        _init(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod);\n    }\n\n    function _init(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) internal {\n        require(parameters.startTime == 0, \"ALREADY_INITIALISED\");\n        // require(commit3HPeriod >= 2, \"COMMIT_PERIOD_TOO_SHORT\"); // 6 hours\n        // require(commit3HPeriod >= 8 ? reveal3HPeriod >= 8: reveal3HPeriod >= commit3HPeriod, \"REVEAL_PERIOD_TOO_SHORT\");\n        // require(reveal3HPeriod <= 24, \"REVEAL_PERIOD_TOO_LONG\"); // 3 days\n        // require(commit3HPeriod >= 8 ? winner3HPeriod >= 8: winner3HPeriod >= commit3HPeriod, \"WINNER_PERIOD_TOO_SHORT\");\n        // require(winner3HPeriod <= 24, \"WINNER_PERIOD_TOO_LONG\"); // 3 days\n        parameters.loot = loot;\n        parameters.winnerGetLoot = winnerGetLoot;\n        parameters.startTime = uint40(block.timestamp);\n        parameters.commit3HPeriod = commit3HPeriod;\n        parameters.reveal3HPeriod = reveal3HPeriod;\n        parameters.winner3HPeriod = winner3HPeriod;\n    }\n\n    function freeFormInit(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) public {\n        _init(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod);\n    }\n\n    function init(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) public {\n        require(address(loot) != address(0), \"INVALID_ZERO_LOOT\");\n        require(address(loot) == _originalLoot || address(loot) == _mloot || address(loot) == _lootForEveryone, \"INVALID LOOT\");\n        _init(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod);\n    }\n\n    function clone(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) external returns (address) {\n        return _clone(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod, true);\n    }\n\n    function freeFormClone(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod\n    ) external returns (address) {\n        return _clone(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod, false);\n    }\n\n    function _clone(\n        ILoot loot,\n        bool winnerGetLoot,\n        uint8 commit3HPeriod,\n        uint8 reveal3HPeriod,\n        uint8 winner3HPeriod,\n        bool generateXP\n    ) internal returns(address) {\n        address implementation;\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            implementation := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\n        }\n        if (implementation == address(0)) {\n            implementation = address(this);\n        }\n        address yooloot = Clones.clone(implementation);\n        if (generateXP) {\n            YooLoot(yooloot).init(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod);\n            _lootXP.setSource(yooloot, true);\n        } else {\n            YooLoot(yooloot).freeFormInit(loot, winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod);\n        }\n        emit Cloned(address(loot), winnerGetLoot, commit3HPeriod, reveal3HPeriod, winner3HPeriod, yooloot, generateXP);\n        return yooloot;\n    }\n\n    function commitLootDeck(uint256 lootId, bytes32 deckHash) external {\n        require((block.timestamp - parameters.startTime) < (3 hours * uint256(parameters.commit3HPeriod)), \"COMMIT_PERIOD_OVER\");\n        require(deckHash != 0x0000000000000000000000000000000000000000000000000000000000000001, \"INVALID HASH\");\n        deckHashes[lootId] = deckHash;\n        deposits[lootId] = msg.sender;\n        parameters.loot.transferFrom(msg.sender, address(this), lootId);\n        emit LootDeckSubmitted(msg.sender, lootId, deckHash);\n    }\n\n    function changeDeck(uint256 oldLootId, uint256 lootId, bytes32 deckHash) external {\n        require((block.timestamp - parameters.startTime) < (3 hours * uint256(parameters.commit3HPeriod)), \"COMMIT_PERIOD_OVER\");\n        require(deckHash != 0x0000000000000000000000000000000000000000000000000000000000000001, \"INVALID HASH\");\n        require(deckHash != 0x0000000000000000000000000000000000000000000000000000000000000000, \"NEVER_SUBMITTED\");\n\n        require(msg.sender == deposits[oldLootId], \"NOT_YOUR_LOOT\");\n        deckHashes[lootId] = deckHash;\n        if (oldLootId != lootId) {\n            deckHashes[oldLootId] = 0x0000000000000000000000000000000000000000000000000000000000000000;\n            deposits[oldLootId] = address(0);\n            deposits[lootId] = msg.sender;\n            parameters.loot.safeTransferFrom(address(this), msg.sender, oldLootId);\n            parameters.loot.transferFrom(msg.sender, address(this), lootId);\n        }\n\n        emit LootDeckCanceled(msg.sender, oldLootId);\n        emit LootDeckSubmitted(msg.sender, lootId, deckHash);\n    }\n\n    function cancelDeck(uint256 oldLootId) external {\n        require((block.timestamp - parameters.startTime) < (3 hours * uint256(parameters.commit3HPeriod)), \"COMMIT_PERIOD_OVER\");\n        require(msg.sender == deposits[oldLootId], \"NOT_YOUR_LOOT\");\n        deckHashes[oldLootId] = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        deposits[oldLootId] = address(0);\n        parameters.loot.safeTransferFrom(address(this), msg.sender, oldLootId);\n        emit LootDeckCanceled(msg.sender, oldLootId);\n    }\n\n    function revealLootDeck(\n        uint256 lootId,\n        uint8[8] calldata deckWithStartIndex1,\n        bytes32 secret\n    ) external {\n        uint256 commitPeriod = (3 hours * uint256(parameters.commit3HPeriod));\n        uint256 timePassed = block.timestamp - parameters.startTime;\n\n        require(timePassed > commitPeriod, \"REVEAL_PERIOD_NOT_STARTED\");\n\n        require(timePassed < commitPeriod + 3 hours * uint256(parameters.reveal3HPeriod), \"REVEAL_PERIOD_OVER\");\n\n        bytes32 deckHash = deckHashes[lootId];\n        require(deckHash != 0x0000000000000000000000000000000000000000000000000000000000000001, \"ALREADY_REVEALED\");\n        require(deckHash != 0x0000000000000000000000000000000000000000000000000000000000000000, \"NEVER_SUBMITTED\");\n\n        require(keccak256(abi.encodePacked(secret, lootId, deckWithStartIndex1)) == deckHash, \"INVALID_SECRET'\");\n        deckHashes[lootId] = 0x0000000000000000000000000000000000000000000000000000000000000001;\n        uint8[8] memory indicesUsed;\n        for (uint8 i = 0; i < 8; i++) {\n            uint8 index = deckWithStartIndex1[i] - 1;\n            indicesUsed[index]++;\n            uint8 power = pluckPower(lootId, index, address(parameters.loot) == _lootForEveryone);\n            uint256 current = rounds[i][power];\n            if (current == 0) {\n                rounds[i][power] = lootId;\n            } else if (current != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                rounds[i][power] = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n            }\n        }\n        for (uint8 i = 0; i < 8; i++) {\n            require(indicesUsed[i] == 1, \"INVALID_DECK\");\n        }\n        emit LootDeckRevealed(lootId, deckWithStartIndex1);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function winner()\n        public\n        view\n        returns (\n            address winnerAddress,\n            uint256 winnerLootId,\n            uint256 winnerScore\n        )\n    {\n        require((block.timestamp - parameters.startTime) > (3 hours * (uint256(parameters.commit3HPeriod) + uint256(parameters.reveal3HPeriod))), \"REVEAL_PERIOD_NOT_OVER\");\n\n        uint256[8] memory winnerLootPerRound;\n        for (uint8 round = 0; round < 8; round++) {\n            for (uint8 power = 126; power > 0; power--) {\n                uint256 lootId = rounds[round][power - 1];\n                if (lootId > 0 && lootId != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                    winnerLootPerRound[round] = lootId;\n                    winnerAddress = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n                    break;\n                }\n            }\n        }\n\n        if (winnerAddress != 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF) { // nobody won a round;\n            return (address(0), 0, 0);\n        }\n\n        for (uint8 i = 0; i < 8; i++) {\n            uint8 extra = 0;\n            uint8 tmpScore;\n            for (uint8 j = 0; j < 8; j++) {\n                if (winnerLootPerRound[j] == 0) {\n                    extra += (j + 1);\n                } else if (winnerLootPerRound[j] == winnerLootPerRound[i]) {\n                    tmpScore += extra + (j + 1);\n                    extra = 0;\n                }\n            }\n            if (tmpScore >= winnerScore) {\n                // give more power to player who win later rounds\n                winnerLootId = winnerLootPerRound[i];\n                winnerScore = tmpScore;\n            }\n        }\n        winnerAddress = deposits[winnerLootId];\n    }\n\n    // solhint-disable-next-line code-complexity\n    function individualScore(uint256 lootId) public view returns (uint256 score) {\n        require(\n            lootId > 0 && lootId != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,\n            \"INVALID_LOOT\"\n        );\n\n        require((block.timestamp - parameters.startTime) > (3 hours * (uint256(parameters.commit3HPeriod) + uint256(parameters.reveal3HPeriod))), \"REVEAL_PERIOD_NOT_OVER\");\n\n        uint256 extra = 0;\n        for (uint8 round = 0; round < 8; round++) {\n            bool anyone = false;\n            for (uint8 power = 126; power > 0; power--) {\n                uint256 lootIdHere = rounds[round][power - 1];\n                if (lootIdHere == lootId) {\n                    score += (round + 1) + extra;\n                    anyone = true;\n                    break;\n                } else if (\n                    lootIdHere > 0 && lootIdHere != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                ) {\n                    anyone = true;\n                    break;\n                }\n            }\n            if (!anyone) {\n                extra += (round + 1);\n            } else {\n                extra = 0;\n            }\n        }\n    }\n\n    ///@notice get all info in the minimum calls\n    function getTokenDataOfOwner(\n        address owner,\n        uint256 start,\n        uint256 num\n    ) external view returns (TokenData[] memory tokens) {\n        uint256 balance = parameters.loot.balanceOf(owner);\n        require(balance >= start + num, \"TOO_MANY_TOKEN_REQUESTED\");\n        tokens = new TokenData[](num);\n        uint8[8] memory baseDeck = [1,2,3,4,5,6,7,8];\n        uint256 i = 0;\n        while (i < num) {\n            uint256 id = parameters.loot.tokenOfOwnerByIndex(owner, start + i);\n            tokens[i] = TokenData(id, parameters.loot.tokenURI(id), getDeckPower(id, baseDeck, address(parameters.loot) == _lootForEveryone));\n            i++;\n        }\n    }\n\n    function getTokenData(\n        uint256 id\n    ) external view returns (TokenData memory) {\n        uint8[8] memory baseDeck = [1,2,3,4,5,6,7,8];\n        return TokenData(id, parameters.loot.tokenURI(id), getDeckPower(id, baseDeck, address(parameters.loot) == _lootForEveryone));\n    }\n\n    function claimVictoryLoot(uint256 lootToPick) external {\n        require(parameters.winnerGetLoot, \"NO_LOOT_TO_WIN\");\n\n        require((block.timestamp - parameters.startTime) < (3 hours * (uint256(parameters.commit3HPeriod) + uint256(parameters.reveal3HPeriod) + uint256(parameters.winner3HPeriod))), \"VICTORY_PERIOD_OVER\");\n\n        (address winnerAddress, , ) = winner();\n        require(winnerAddress == msg.sender, \"NOT_WINNER\");\n        address takenFrom = deposits[lootToPick];\n        require(takenFrom != msg.sender, \"ALREADY_OWNER\");\n        parameters.loot.safeTransferFrom(address(this), msg.sender, lootToPick);\n        parameters.startTime = 1;\n\n        emit WinnerWithdrawal(msg.sender, takenFrom, lootToPick);\n    }\n\n    function claimVictoryERC20(IERC20 token) external {\n        require(address(token) != address(parameters.loot), \"INVALID_ERC20\");\n        (address winnerAddress, , ) = winner();\n        require(winnerAddress == msg.sender, \"NOT_WINNER\");\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function withdrawAndGetXP(uint256 lootId) external {\n        (address winnerAddress, uint256 winnerLootId, uint256 winnerScore) = winner();\n\n        if (!((block.timestamp - parameters.startTime) > (3 hours * (uint256(parameters.commit3HPeriod) + uint256(parameters.reveal3HPeriod) + uint256(parameters.winner3HPeriod))))) {\n            require(winnerAddress == address(0), \"VICTORY_PERIOD_NOT_OVER\");\n        }\n\n        require(deposits[lootId] == msg.sender, \"NOT_OWNER\");\n        require(\n            deckHashes[lootId] == 0x0000000000000000000000000000000000000000000000000000000000000001,\n            \"DID_NOT_REVEAL\"\n        );\n        parameters.loot.safeTransferFrom(address(this), msg.sender, lootId);\n        uint256 xpGained;\n        if (lootId == winnerLootId) {\n            xpGained = 10000 * winnerScore;\n        } else {\n            uint256 score = individualScore(lootId);\n            xpGained = 100 + 1000 * score;\n        }\n\n        if (!_lootXP.addXP(lootId, xpGained)) {\n            xpGained = 0;\n        }\n\n        emit LootWithdrawn(msg.sender, lootId, xpGained);\n    }\n\n    function getDeckPower(uint256 lootId, uint8[8] memory deckWithStartIndex1, bool lootForEveryone) public pure returns (uint8[8] memory deckPower) {\n        for (uint8 i = 0; i < 8; i++) {\n            deckPower[i] = pluckPower(lootId, deckWithStartIndex1[i] - 1, lootForEveryone);\n        }\n    }\n\n    // -----------------------------------------------------------\n\n    function pluckPower(uint256 lootId, uint256 gearType, bool lootForEveryone) internal pure returns (uint8 power) {\n        (uint256 index, uint256 greatness) = pluck(lootId, gearType, lootForEveryone);\n        if (greatness <= 14) {\n            greatness = 3;\n        } else if (greatness == 19) {\n            greatness = 1;\n        } else if (greatness == 20) {\n            greatness = 0;\n        } else {\n            greatness = 2;\n        }\n        if (gearType == 0) {\n            return uint8(125 - index);\n        } else if (gearType < 6) {\n            return uint8(125 - (18 + (gearType - 1) * 15 + index));\n        } else if (gearType == 6) {\n            return uint8(125 - (18 + 5 * 15 + index * 4 + greatness));\n        } else {\n            return uint8(125 - (18 + 5 * 15 + 3 * 4 + index * 4 + greatness));\n        }\n    }\n\n    // solhint-disable-next-line code-complexity\n    function pluck(uint256 tokenId, uint256 gearType, bool lootForEveryone) internal pure returns (uint256 index, uint256 greatness) {\n        string memory keyPrefix = \"WEAPON\";\n        uint256 length = 18;\n        if (gearType == 1) {\n            keyPrefix = \"CHEST\";\n            length = 15;\n        } else if (gearType == 2) {\n            keyPrefix = \"HEAD\";\n            length = 15;\n        } else if (gearType == 3) {\n            keyPrefix = \"WAIST\";\n            length = 15;\n        } else if (gearType == 4) {\n            keyPrefix = \"FOOT\";\n            length = 15;\n        } else if (gearType == 5) {\n            keyPrefix = \"HAND\";\n            length = 15;\n        } else if (gearType == 6) {\n            keyPrefix = \"NECK\";\n            length = 3;\n        } else if (gearType == 7) {\n            keyPrefix = \"RING\";\n            length = 5;\n        }\n\n        // TODO test if necessary\n        uint256 rand;\n        if (!lootForEveryone || tokenId < 8001) {\n            rand = random(string(abi.encodePacked(keyPrefix, toString(tokenId))));\n        } else {\n            rand = random(string(abi.encodePacked(keyPrefix, abi.encodePacked(address(uint160(tokenId))))));\n        }\n\n        index = rand % length;\n        greatness = rand % 21;\n    }\n\n    // TODO test\n    // solhint-disable-next-line code-complexity\n    function pluckGreatness(uint256 tokenId, uint256 gearType) internal pure returns (uint8) {\n        string memory keyPrefix = \"WEAPON\";\n        if (gearType == 1) {\n            keyPrefix = \"CHEST\";\n        } else if (gearType == 2) {\n            keyPrefix = \"HEAD\";\n        } else if (gearType == 3) {\n            keyPrefix = \"WAIST\";\n        } else if (gearType == 4) {\n            keyPrefix = \"FOOT\";\n        } else if (gearType == 5) {\n            keyPrefix = \"HAND\";\n        } else if (gearType == 6) {\n            keyPrefix = \"NECK\";\n        } else if (gearType == 7) {\n            keyPrefix = \"RING\";\n        }\n        uint256 rand;\n        if (tokenId < 8001) {\n            rand = random(string(abi.encodePacked(keyPrefix, toString(tokenId))));\n        } else {\n            rand = random(string(abi.encodePacked(keyPrefix, abi.encodePacked(address(uint160(tokenId))))));\n        }\n\n        uint8 greatness = uint8(rand % 21);\n        return greatness;\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function random(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n}\n"
    },
    "src/interfaces/ILootXP.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.7;\n\ninterface ILootXP{\n    function xp(uint256 lootId) external returns (uint256);\n\n    function xpSource(address source) external returns (bool);\n\n    function xpSink(address sink) external returns (bool);\n\n    function generator(address generator) external returns (bool);\n\n    function addXP(uint256 lootId, uint256 amount) external returns (bool);\n\n    function removeXP(uint256 lootId, uint256 amount) external returns (bool);\n\n    function setSource(address source, bool add) external;\n\n    function setSink(address sink, bool add) external;\n\n    function setGenerator(address generator, bool add) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}